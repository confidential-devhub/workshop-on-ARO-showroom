= Add secrets to Trustee

pass:[<span style="color: red;"><b>PERSONA:</b></span>] Application developer

You can assume that **everything running in the trustee-operator-system namespace should run in a trusted, separate environment**. Because of the limitations of this ARO workshop, it is not possible to set up two clusters.

[NOTE]
====
There is no automation script here, as the example `attestation-status` secret is optional and it's part of the minimal required knowledge that the application developer has to have.
====

In this section, we are transiting to the role of **application developer**. The application developer usually has control of the application-specific secrets, and is only instructed by the operational security persona on how to add them into Trustee. There is no CoCo knowledge required for this persona.

We will now populate Trustee with secret(s) that are then managed by the xref:configure-trustee.adoc[previously set] policies and if attestation is successful, are sent to the client(s) (CoCo). For example, a Confidential Container workload could be shipped without credentials to access remote data, as they are stored inside the Trustee and provided only if attestation is successful. In this section, we will show just a simple example, whereas later the application developer will add more concrete use cases.

[#trustee-ex-sec]
== Add a secret into the Trustee namespace

The "secret" (key, credential) can be added into the OCP trusted cluster just like any other key, via traditional Openshift Secrets:

[source,sh,role=execute]
----
# default attestation check
oc create secret generic attestation-status \
  --from-literal status=success \
  -n trustee-operator-system
----

And then we need to instruct Trustee to load that secret into its deployment, by updating the KbsConfig.

[#kbsconfig-secrets]
== Update the KbsConfig

In order to add our newly uploaded secret into Trustee, we need to update the KbsConfig:

[source,sh,role=execute]
----
echo "Default Kbsconfig - kbsSecretResources:"
oc get kbsconfig trusteeconfig-kbs-config -n trustee-operator-system -o json \
  | jq '.spec.kbsSecretResources'

echo ""

oc patch kbsconfig trusteeconfig-kbs-config \
  -n trustee-operator-system \
  --type=json \
  -p="[
    {\"op\": \"add\", \"path\": \"/spec/kbsSecretResources/-\", \"value\": \"attestation-status\"},
  ]"

echo ""

echo "Updated Kbsconfig - kbsSecretResources:"
oc get kbsconfig trusteeconfig-kbs-config -n trustee-operator-system -o json \
  | jq '.spec.kbsSecretResources'
----

Once the KbsConfig has been configured, restart the deployment to apply the changes.

[source,sh,role=execute]
----
oc rollout restart deployment/trustee-deployment -n trustee-operator-system
----

That's it!

Now we will explain how can an application fetch (manually or automatically) such secrets, without knowing anything about Trustee, but reliying on the CoCo components inside the Confidential VM.

[#fetch-secrets]
== How to fetch the Trustee secrets (attestation)

The main goal in the CoCo architecture model is to not affect the main container/application logic, therefore the workload itself should not perform any different action than the ones that it would do in a traditional container.

A secret can be fetched in two ways, and the xref:hello-openshift.adoc[hello-openshift] example application shows both: lazy attestaion and sealed secrets.

[#lazy-attestation]
=== Lazy attestation

Lazy attestation simply means that the pod has to retrieve the secret itself by connecting with the **internal** guest components (the container does not need to know the Trustee address!).

From the application developer prospective, all that is needed to do to trigger attestation is to query localhost:8006 with the path of the secret that we need, and if it is received, everything is working well. CoCo internal components will take care of connecting with Trustee (as we saw in the xref:configure-trustee.adoc[Trustee configuration], this is coming from the initdata and measured in the reference values).

Such work can be done via sidecars, leaving the main application workflow intact, and can be repeated as needed, to regularly check the security status of the container.

The main disadvantage is that one has to build an additional sidecar that:
* is able to download a file (despite being to localhost)
* knows which secret is needed and at which path is loaded. For example, the `attestation-status` secret loaded above will be available at `default/attestation-status/status`.

Lazy attestation via sidecars is ideal when we want to periodically monitor the CoCo pod attestation status, by periodically querying for simple, useless secrets like the above `status`.

Here an example of such sidecar:

[source,sh,role=execute]
----
[...]
containers:
  - name: attestation-checker
    image: registry.access.redhat.com/ubi9/ubi-minimal
    command:
      - /bin/sh
      - -c
      - |
        while true; do
          STATUS=$(curl -sf http://localhost:8006/default/attestation-status/status || echo "error")
          if [ "$STATUS" != "success" ]; then
            echo "Attestation status FAILED: $STATUS"
            exit 1
          fi
          sleep 30
        done
[...]
----

[#sealed-secrets]
=== Sealed secrets

A sealed secret is an Openshift Secret added into the untrusted cluster, where the CoCo application runs, that doesn't really contain any value but rather a "pointer" to the actual secret stored into Trustee, in the trusted cluster.

Once the CoCo pod starts, this sealed is inspected by the internal CoCo components, and the corresponding attestation and secret retrieval is automatically initiated with Trustee. If attestation is successful, the content of this "pointer" secret will be replaced with the actual secret, and mounted just like any other secret into the container.

The advantage of this approach is that:
* the secret is loaded at startup time. No need of a sidecar or any special logic, the CoCo internal components take care of connecting with Trustee and fetching the actual value of the secret.
.. the secret is no different from a traditional openshift secret. While it requires an additional step to be created in the application namespace, this secret is no different from a traditional one, and can be accessed as volume by the pod.

Sealed secrets are ideal to load credentials and sensitive data as traditional Secrets into the workload, without the need to add any sophisticated logic.

In order to create a sealed secret, we need to create this special secret into the untrusted cluster, in the namespace where the application will run. Supposing that we want to add a secret referencing the `attestation-status` Trustee secret created above, we will need to create the pointer first and then the actual secret.

Create the "pointer":
[source,sh,role=execute]
----
SECRET_NAME=attestation-status
KEY_NAME=status

POINTER=$(podman run -it quay.io/confidential-devhub/coco-tools:0.3.0 /tools/secret seal vault --resource-uri kbs:///default/${SECRET_NAME}/${KEY_NAME} --provider kbs | grep -v "Warning")

echo $POINTER
----

We can add this "pointer" to the CoCo container in multiple ways, either as secret/configmap, or as env variable. Therefore let's assume the application runs in the `default` namespace of the **untrusted** cluster, and let's add the secret there.

NOTE: Because this is stored/loaded in the untrusted OCP cluster, one might think that any attacker with cluster access could modify it. And while this is true, recall that this is just a pointer to the secret, and does not define the policy to access it nor the Trustee address. Which means that in the worst case this secret will point to a non-existing Trustee resource, or a valid but inaccessible resource, if Trustee policies are strict enough.

And now let's load the OCP Secret with this pointer:

[source,sh,role=execute]
----
# Note that the namespace here is "default"!
oc create secret generic sealed-secret --from-literal=attstatus=$POINTER -n default
----

That's it! Now the application can load it as a normal Secret volume:

[source,sh,role=execute]
----
[...]
  containers:
    - name: my-container
      volumeMounts:
        - name: sealed-secret-volume
          mountPath: "/sealed/secret-value"
  volumes:
    - name: sealed-secret-volume
      secret:
        secretName: sealed-secret
----

And the container will find the content of `attestation-status/status` in `/sealed/secret-value/attstatus`!

Alternatively, this pointer can also be also directly plugged in the podspec as environment variable:

[source,sh,role=execute]
----
[...]
env:
   - name: MY_VARIABLE
   - value: $POINTER
[...]
----

And $MY_VARIABLE will contain the content of `attestation-status/status`!


